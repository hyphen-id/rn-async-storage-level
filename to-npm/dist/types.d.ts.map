{"mappings":"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","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type { AsyncStorageStatic } from '@react-native-async-storage/async-storage'\nimport type { AbstractKeyIteratorOptions, AbstractLevel as AbstractLevelType } from 'abstract-level'\nimport {\n  AbstractDatabaseOptions,\n  AbstractIterator,\n  AbstractKeyIterator,\n  AbstractLevel,\n  AbstractValueIterator\n} from 'abstract-level'\n\nexport type LevelErrorCode =\n  | 'LEVEL_PUT_ERROR'\n  | 'LEVEL_NOT_FOUND'\n  | 'LEVEL_GET_ERROR'\n  | 'LEVEL_DEL_ERROR'\n  | 'LEVEL_INVALID_VALUE'\n\nexport class LevelError extends Error {\n  public code: LevelErrorCode\n\n  constructor(message: string, code: LevelErrorCode) {\n    super(message)\n    this.name = 'LevelError'\n    this.code = code\n  }\n}\n\nexport type ValueType = string | number | boolean | null | undefined\n\nexport class RNAsyncStorageLevel extends AbstractLevel<string, string, ValueType> {\n  protected storage: AsyncStorageStatic\n\n  protected location: string\n\n  constructor(storage: AsyncStorageStatic, location: string, options?: AbstractDatabaseOptions<string, string>) {\n    const manifest: Partial<AbstractLevelType<string>['supports']> = {\n      getMany: true,\n      snapshots: false,\n      permanence: true,\n      keyIterator: false,\n      valueIterator: false,\n      iteratorNextv: false,\n      iteratorAll: true,\n      streams: false,\n      seek: false,\n      encodings: {\n        utf8: true\n      },\n      events: {\n        opening: true,\n        open: true,\n        closing: true,\n        closed: true,\n        put: true,\n        del: true,\n        batch: false,\n        clear: true\n      }\n    }\n    const mergedOptions: AbstractDatabaseOptions<string, string> = {\n      createIfMissing: true,\n      errorIfExists: false,\n      keyEncoding: 'utf8',\n      valueEncoding: 'utf8',\n      ...options\n    }\n\n    super(manifest, mergedOptions)\n    this.location = location\n    this.storage = storage\n  }\n\n  protected _open(options: any, callback: (err?: Error | null) => void = () => {}): void {\n    // AsyncStorage does not need an explicit open call.\n    queueMicrotask(() => {\n      callback()\n    })\n  }\n\n  protected _close(callback: (err?: Error | null) => void = () => {}): void {\n    // AsyncStorage does not need an explicit close call.\n    queueMicrotask(() => {\n      callback()\n    })\n  }\n\n  protected _get(\n    key: string,\n    options: any,\n    callback?: (err: Error | null, value?: ValueType) => void\n  ): void | Promise<ValueType> {\n    if (callback) {\n      this.storage.getItem(`${this.location}/${key}`).then((value) => {\n        if (value === null || value === undefined) {\n          queueMicrotask(() => {\n            callback(new LevelError(`Key ${key} not found`, 'LEVEL_NOT_FOUND'))\n          })\n        } else {\n          queueMicrotask(() => {\n            callback(null, value)\n          })\n        }\n      })\n    } else {\n      return new Promise<ValueType>((resolve, reject) => {\n        this.storage.getItem(`${this.location}/${key}`).then((value) => {\n          if (value === null || value === undefined) {\n            reject(new LevelError(`Key ${key} not found`, 'LEVEL_NOT_FOUND'))\n          } else {\n            resolve(value)\n          }\n        })\n      })\n    }\n  }\n\n  public _getAllKeys(callback?: (err: Error | null, keys?: string[]) => void): void | Promise<string[]> {\n    if (callback) {\n      this.storage\n        .getAllKeys()\n        .then((keys) =>\n          queueMicrotask(() => {\n            callback(\n              null,\n              keys.filter((key) => key.startsWith(this.location)).map((key) => key.replace(`${this.location}/`, ''))\n            )\n          })\n        )\n        .catch((err) =>\n          queueMicrotask(() => {\n            callback(err)\n          })\n        )\n    } else {\n      return new Promise<string[]>((resolve, reject) => {\n        this.storage\n          .getAllKeys()\n          .then((keys) =>\n            resolve(\n              keys.filter((key) => key.startsWith(this.location)).map((key) => key.replace(`${this.location}/`, ''))\n            )\n          )\n          .catch((err) => reject(err))\n      })\n    }\n  }\n\n  protected _getMany(\n    keys: string[],\n    options: any,\n    callback: (err: Error | null, value?: ValueType[]) => void\n  ): void | Promise<ValueType[]> {\n    if (callback) {\n      this.storage\n        .multiGet(keys.map((key) => `${this.location}/${key}`))\n        .then((results) =>\n          queueMicrotask(() => {\n            callback(\n              null,\n              results.map(([key, value]) => value)\n            )\n          })\n        )\n        .catch((err) =>\n          queueMicrotask(() => {\n            callback(err)\n          })\n        )\n    } else {\n      return new Promise<ValueType[]>((resolve, reject) => {\n        this.storage\n          .multiGet(keys.map((key) => `${this.location}/${key}`))\n          .then((results) => resolve(results.map(([key, value]) => value)))\n          .catch((err) => reject(err))\n      })\n    }\n  }\n\n  protected _put(\n    key: string,\n    value: string,\n    options: any,\n    callback: (err?: Error | null) => void\n  ): void | Promise<void> {\n    if (callback) {\n      this.storage\n        .setItem(`${this.location}/${key}`, value)\n        .then(() =>\n          queueMicrotask(() => {\n            callback()\n          })\n        )\n        .catch((err) =>\n          queueMicrotask(() => {\n            callback(new LevelError(err.message, 'LEVEL_PUT_ERROR'))\n          })\n        )\n    } else {\n      return new Promise<void>((resolve, reject) => {\n        this.storage\n          .setItem(`${this.location}/${key}`, value)\n          .then(() => resolve())\n          .catch((err) => reject(new LevelError(err.message, 'LEVEL_PUT_ERROR')))\n      })\n    }\n  }\n\n  protected _del(key: string, options: any, callback: (err?: Error | null) => void): void | Promise<void> {\n    if (callback) {\n      this.storage\n        .removeItem(`${this.location}/${key}`)\n        .then(() =>\n          queueMicrotask(() => {\n            callback()\n          })\n        )\n        .catch((err) =>\n          queueMicrotask(() => {\n            callback(new LevelError(err.message, 'LEVEL_DEL_ERROR'))\n          })\n        )\n    } else {\n      return new Promise<void>((resolve, reject) => {\n        this.storage\n          .removeItem(`${this.location}/${key}`)\n          .then(() => resolve())\n          .catch((err) => reject(new LevelError(err.message, 'LEVEL_DEL_ERROR')))\n      })\n    }\n  }\n\n  protected _clear(options: any, callback: (err?: Error | null) => void): void | Promise<void> {\n    if (callback) {\n      this.storage\n        .getAllKeys()\n        .then((keys) => {\n          const keysInLocation = keys.filter((key) => key.startsWith(`${this.location}/`))\n          return this.storage.multiRemove(keysInLocation)\n        })\n        .then(() =>\n          queueMicrotask(() => {\n            callback()\n          })\n        )\n        .catch((err) =>\n          queueMicrotask(() => {\n            callback(new LevelError(err.message, 'LEVEL_DEL_ERROR'))\n          })\n        )\n    } else {\n      return new Promise<void>((resolve, reject) => {\n        this.storage\n          .getAllKeys()\n          .then((keys) => {\n            const keysInLocation = keys.filter((key) => key.startsWith(`${this.location}/`))\n            return this.storage.multiRemove(keysInLocation)\n          })\n          .then(() => resolve())\n          .catch((err) => reject(new LevelError(err.message, 'LEVEL_DEL_ERROR')))\n      })\n    }\n  }\n\n  _iterator(options?: any): AsyncStorageIterator {\n    return new AsyncStorageIterator(this, options)\n  }\n\n  _keys(options?: AbstractKeyIteratorOptions<string>): AsyncStorageKeyIterator {\n    return new AsyncStorageKeyIterator(this, options)\n  }\n\n  _values(options?: any): AsyncStorageValueIterator {\n    return new AsyncStorageValueIterator(this, options)\n  }\n}\n\nexport class AsyncStorageIterator extends AbstractIterator<RNAsyncStorageLevel, string, ValueType> {\n  private keys: string[]\n\n  private currentIndex: number\n\n  constructor(database: RNAsyncStorageLevel, options: any) {\n    super(database, options)\n    this.keys = []\n    this.currentIndex = 0\n  }\n\n  // TODO: fix\n  // async _next(callback: (err?: Error | null, key?: string, value?: ValueType) => void): Promise<void> {\n  //   if (!this.keys.length) {\n  //     this.keys = (await this.db._getAllKeys()) as string[]\n  //   }\n  //   if (this.currentIndex >= this.keys.length) {\n  //     callback()\n  //     return\n  //   }\n\n  //   const key = this.keys[this.currentIndex++]\n  //   const value = (await this.db.get(key)) as ValueType\n  //   callback(null, key, value)\n  // }\n\n  // async _nextv(\n  //   size = 0,\n  //   options?: any,\n  //   callback?: (err: Error | null, entries?: [string, ValueType][]) => void\n  // ): Promise<void> {\n  //   if (!this.keys.length) {\n  //     this.keys = (await this.db._getAllKeys()) as string[]\n  //   }\n  //   const entries: [string, ValueType][] = []\n  //   const endIndex = Math.min(this.currentIndex + size, this.keys.length)\n  //   for (; this.currentIndex < endIndex; this.currentIndex++) {\n  //     const key = this.keys[this.currentIndex]\n  //     const value = (await this.db.get(key)) as ValueType\n  //     entries.push([key, value])\n  //   }\n  //   callback(null, entries)\n  // }\n\n  async _all(options: any, callback: (err: Error | null, entries?: [string, ValueType][]) => void): Promise<void> {\n    if (!this.keys.length) {\n      this.keys = (await this.db._getAllKeys()) as string[]\n    }\n    const entries: [string, ValueType][] = []\n    for (; this.currentIndex < this.keys.length; this.currentIndex++) {\n      const key = this.keys[this.currentIndex]\n      const value = (await this.db.get(key)) as ValueType\n      entries.push([key, value])\n    }\n    queueMicrotask(() => callback(null, entries))\n  }\n\n  _close(callback: () => void) {\n    this.keys = []\n    this.currentIndex = 0\n    queueMicrotask(() => callback())\n  }\n}\n\nexport class AsyncStorageKeyIterator extends AbstractKeyIterator<RNAsyncStorageLevel, string> {\n  private keys: string[]\n\n  private currentIndex: number\n\n  constructor(db: RNAsyncStorageLevel, options: AbstractKeyIteratorOptions<string>) {\n    super(db, options)\n    this.keys = []\n    this.currentIndex = 0\n  }\n\n  // TODO: fix\n  // async _next(callback: (err?: Error | null, key?: string) => void): Promise<void> {\n  //   if (!this.keys.length) {\n  //     this.keys = (await this.db._getAllKeys()) as string[]\n  //   }\n  //   if (this.currentIndex >= this.keys.length) {\n  //     queueMicrotask(() => callback())\n  //     return\n  //   }\n\n  //   const key = this.keys[this.currentIndex++]\n  //   queueMicrotask(() => callback(null, key))\n  // }\n\n  // async _nextv(size: number, options: any, callback: (err: Error | null, keys?: string[]) => void): Promise<void> {\n  //   if (!this.keys.length) {\n  //     this.keys = (await this.db._getAllKeys()) as string[]\n  //   }\n  //   const keys = this.keys.slice(this.currentIndex, this.currentIndex + size)\n  //   this.currentIndex += keys.length\n  //   queueMicrotask(() => callback(null, keys))\n  // }\n\n  async _all(options: any, callback: (err: Error | null, keys?: string[]) => void): Promise<void> {\n    if (!this.keys.length) {\n      this.keys = (await this.db._getAllKeys()) as string[]\n    }\n    const keys = this.keys.slice(this.currentIndex)\n    this.currentIndex = this.keys.length\n    queueMicrotask(() => callback(null, keys))\n  }\n\n  _close(callback: () => void) {\n    this.keys = []\n    this.currentIndex = 0\n    queueMicrotask(() => callback())\n  }\n}\n\nexport class AsyncStorageValueIterator extends AbstractValueIterator<RNAsyncStorageLevel, string, ValueType> {\n  private keys: string[]\n\n  private currentIndex: number\n\n  constructor(db: RNAsyncStorageLevel, options: any) {\n    super(db, options)\n    this.keys = []\n    this.currentIndex = 0\n  }\n  // TODO: fix\n  // async _next(callback: (err?: Error | null, value?: ValueType) => void): Promise<void> {\n  //   if (!this.keys.length) {\n  //     this.keys = (await this.db._getAllKeys()) as string[]\n  //   }\n  //   if (this.currentIndex >= this.keys.length) {\n  //     queueMicrotask(() => callback())\n  //     return\n  //   }\n  //   const key = this.keys[this.currentIndex++]\n  //   const value = (await this.db.get(key)) as ValueType\n  //   queueMicrotask(() => callback(null, value))\n  // }\n\n  // async _nextv(size: number, options: any, callback: (err: Error | null, values?: ValueType[]) => void): Promise<void> {\n  //   if (!this.keys.length) {\n  //     this.keys = (await this.db._getAllKeys()) as string[]\n  //   }\n  //   const endIndex = Math.min(this.currentIndex + size, this.keys.length)\n  //   const fetchPromises = this.keys.slice(this.currentIndex, endIndex).map((key) => this.db.get(key))\n  //   const values = await Promise.all(fetchPromises)\n  //   this.currentIndex = endIndex\n  //   queueMicrotask(() => callback(null, values))\n  // }\n\n  async _all(options: any, callback: (err: Error | null, values?: ValueType[]) => void): Promise<void> {\n    if (!this.keys.length) {\n      this.keys = (await this.db._getAllKeys()) as string[]\n    }\n    const fetchPromises = this.keys.slice(this.currentIndex, this.keys.length).map((key) => this.db.get(key))\n    const values = await Promise.all(fetchPromises)\n    this.currentIndex = this.keys.length\n    queueMicrotask(() => callback(null, values))\n  }\n\n  _close(callback: () => void) {\n    this.keys = []\n    this.currentIndex = 0\n    queueMicrotask(() => callback())\n  }\n}\n"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}